<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘ç²’å­ç‰¹æ•ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #f5f5f5;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .header {
            position: absolute;
            top: 0;
            width: 100%;
            padding: 20px;
            text-align: center;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(10,10,10,0.9) 0%, rgba(10,10,10,0) 100%);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #d4af37, #ffd700, #c5b358);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #aaa;
            margin-bottom: 25px;
            max-width: 800px;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        #canvas-container {
            flex: 1;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        #webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            z-index: 50;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        #webcam-container:hover {
            opacity: 1;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .controls-panel {
            position: absolute;
            left: 20px;
            bottom: 20px;
            background: rgba(20, 20, 20, 0.85);
            border-radius: 15px;
            padding: 20px;
            width: 300px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            backdrop-filter: blur(10px);
            z-index: 50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .controls-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            color: #d4af37;
            font-size: 1.2rem;
        }

        .controls-header i {
            margin-right: 10px;
            font-size: 1.4rem;
        }

        .control-item {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }

        .gesture-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 15px;
            font-size: 1.2rem;
            color: #d4af37;
        }

        .gesture-description {
            flex: 1;
        }

        .gesture-title {
            font-weight: 600;
            color: #f5f5f5;
            margin-bottom: 3px;
        }

        .gesture-desc {
            font-size: 0.9rem;
            color: #aaa;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(20, 20, 20, 0.8);
            border-radius: 10px;
            display: flex;
            align-items: center;
            z-index: 50;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        .status-text {
            font-weight: 600;
        }

        .upload-section {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 50;
            background: rgba(20, 20, 20, 0.85);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            backdrop-filter: blur(10px);
        }

        #photo-upload {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #2a5c2a, #3a7a3a);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            background: linear-gradient(45deg, #3a7a3a, #4a9a4a);
            transform: translateY(-2px);
        }

        .upload-btn i {
            margin-right: 8px;
        }

        .photo-count {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #aaa;
            text-align: center;
        }

        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 10, 10, 0.85);
            padding: 30px;
            border-radius: 15px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            z-index: 100;
            max-width: 500px;
            backdrop-filter: blur(10px);
        }

        .instructions h2 {
            color: #d4af37;
            margin-bottom: 15px;
        }

        .instructions p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .start-btn {
            background: linear-gradient(45deg, #8b0000, #b22222);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: linear-gradient(45deg, #b22222, #d63030);
            transform: scale(1.05);
        }

        .hidden {
            display: none;
        }

        .effect-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 50;
        }

        .effect-btn {
            background: rgba(20, 20, 20, 0.7);
            color: #f5f5f5;
            border: 1px solid rgba(212, 175, 55, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .effect-btn:hover {
            background: rgba(212, 175, 55, 0.2);
        }

        .photo-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .photo-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            max-width: 80%;
            max-height: 80%;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.5);
            transform: scale(0.8);
            transition: transform 0.5s;
        }

        .photo-modal.active .modal-content {
            transform: scale(1);
        }

        .modal-content img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.8);
            color: #d4af37;
            border: 1px solid rgba(212, 175, 55, 0.5);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.5rem;
            z-index: 201;
        }

        @media (max-width: 768px) {
            .controls-panel {
                width: 250px;
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 0.9rem;
                padding: 0 15px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="header">
        <h1>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘</h1>
        <p class="subtitle">ä½¿ç”¨MediaPipeæ‰‹åŠ¿è¯†åˆ«æ§åˆ¶ç”±ç…§ç‰‡äº‘ã€å‡ ä½•ä½“å’Œç²’å­æ„æˆçš„3Dåœ£è¯æ ‘ã€‚é€šè¿‡æ‰‹åŠ¿åœ¨åˆæ‹¢æ€ã€æ•£å¼€æ€å’Œç…§ç‰‡æ”¾å¤§æ€ä¹‹é—´åˆ‡æ¢ã€‚</p>
    </div>

    <div class="container">
        <div id="canvas-container"></div>
        
        <div class="status-indicator">
            <div class="status-dot" id="status-dot"></div>
            <div class="status-text" id="status-text">ç­‰å¾…æ‘„åƒå¤´å¯åŠ¨</div>
        </div>
        
        <div class="upload-section">
            <label for="photo-upload" class="upload-btn">
                <i class="fas fa-cloud-upload-alt"></i> ä¸Šä¼ ç…§ç‰‡
            </label>
            <input type="file" id="photo-upload" accept="image/*" multiple>
            <div class="photo-count" id="photo-count">å·²åŠ è½½ 6 å¼ é»˜è®¤ç…§ç‰‡</div>
        </div>
        
        <div class="controls-panel">
            <div class="controls-header">
                <i class="fas fa-hand-point-up"></i> æ‰‹åŠ¿æ§åˆ¶è¯´æ˜
            </div>
            <div class="control-item">
                <div class="gesture-icon">
                    <i class="fas fa-hand-rock"></i>
                </div>
                <div class="gesture-description">
                    <div class="gesture-title">æ¡æ‹³</div>
                    <div class="gesture-desc">åœ£è¯æ ‘å›åˆ°åˆæ‹¢æ€</div>
                </div>
            </div>
            <div class="control-item">
                <div class="gesture-icon">
                    <i class="fas fa-hand-paper"></i>
                </div>
                <div class="gesture-description">
                    <div class="gesture-title">å¼ å¼€æ‰‹æŒ</div>
                    <div class="gesture-desc">åœ£è¯æ ‘è¿›å…¥æ•£å¼€æ€</div>
                </div>
            </div>
            <div class="control-item">
                <div class="gesture-icon">
                    <i class="fas fa-hand-sparkles"></i>
                </div>
                <div class="gesture-description">
                    <div class="gesture-title">æ—‹è½¬æ‰‹æŒ</div>
                    <div class="gesture-desc">åœ¨æ•£å¼€æ€æ—‹è½¬è§†è§’</div>
                </div>
            </div>
            <div class="control-item">
                <div class="gesture-icon">
                    <i class="fas fa-hand-back-fist"></i>
                </div>
                <div class="gesture-description">
                    <div class="gesture-title">æŠ“å–åŠ¨ä½œ</div>
                    <div class="gesture-desc">æŠ“ä½ç…§ç‰‡è¿›å…¥æ”¾å¤§æ€</div>
                </div>
            </div>
        </div>
        
        <div class="effect-controls">
            <button class="effect-btn" id="reset-tree">é‡ç½®åœ£è¯æ ‘</button>
            <button class="effect-btn" id="toggle-glow">åˆ‡æ¢è¾‰å…‰æ•ˆæœ</button>
        </div>
        
        <div id="webcam-container">
            <video id="webcam" autoplay playsinline></video>
        </div>
    </div>
    
    <div class="instructions" id="instructions">
        <h2>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘</h2>
        <p>è¿™æ˜¯ä¸€ä¸ªç»“åˆThree.jså’ŒMediaPipe Handsçš„æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘ä½“éªŒã€‚</p>
        <p>åœ£è¯æ ‘ç”±ç…§ç‰‡äº‘ã€å‡ ä½•çƒä½“ã€ç«‹æ–¹ä½“å’Œç³–æœæ£’æ„æˆï¼Œå…·æœ‰ç”µå½±çº§çš„å…‰æ™•ä¸è¾‰å…‰æ•ˆæœã€‚</p>
        <p>è¯·å…è®¸è®¿é—®æ‘„åƒå¤´ä»¥ä½¿ç”¨æ‰‹åŠ¿æ§åˆ¶åŠŸèƒ½ã€‚</p>
        <button class="start-btn" id="start-btn">å¼€å§‹ä½“éªŒ</button>
    </div>
    
    <div class="photo-modal" id="photo-modal">
        <div class="close-modal" id="close-modal">
            <i class="fas fa-times"></i>
        </div>
        <div class="modal-content">
            <img id="modal-image" src="" alt="æ”¾å¤§ç…§ç‰‡">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.156.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.156.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        // å¯¼å…¥Three.jsæ¨¡å—
        import * as THREE from 'three';
        import { EffectComposer } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'https://unpkg.com/three@0.156.0/examples/jsm/postprocessing/OutputPass.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.156.0/examples/jsm/loaders/GLTFLoader.js';

        // å…¨å±€å˜é‡
        let camera, scene, renderer, composer;
        let treeElements = [];
        let photoElements = [];
        let particleSystem;
        let handResults = null;
        let currentState = 'closed'; // closed, open, photo
        let targetPositions = {};
        let transitionProgress = 0;
        let transitionSpeed = 0.05;
        let selectedPhoto = null;
        let photoTextures = [];
        let defaultPhotos = 6;
        let isGlowEnabled = true;
        let bloomPass;
        
        // åˆå§‹åŒ–
        async function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 50);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // åˆ›å»ºåæœŸå¤„ç†
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // è¾‰å…‰æ•ˆæœ
            bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // å¼ºåº¦
                0.4, // åŠå¾„
                0.85 // é˜ˆå€¼
            );
            composer.addPass(bloomPass);
            
            const outputPass = new OutputPass();
            composer.addPass(outputPass);
            
            // æ·»åŠ å…‰æº
            addLights();
            
            // åŠ è½½é»˜è®¤ç…§ç‰‡çº¹ç†
            await loadDefaultTextures();
            
            // åˆ›å»ºåœ£è¯æ ‘å…ƒç´ 
            createChristmasTree();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            // åˆå§‹åŒ–MediaPipe Hands
            initMediaPipe();
            
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            animate();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
            updateStatus('closed', 'åœ£è¯æ ‘åˆæ‹¢æ€');
        }
        
        // æ·»åŠ å…‰æº
        function addLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            // ä¸»å…‰æºï¼ˆé‡‘è‰²ï¼‰
            const mainLight = new THREE.DirectionalLight(0xd4af37, 1.5);
            mainLight.position.set(5, 10, 7);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            scene.add(mainLight);
            
            // è¾…åŠ©å…‰æºï¼ˆçº¢è‰²åœ£è¯è‰²ï¼‰
            const redLight = new THREE.PointLight(0xb22222, 1, 30);
            redLight.position.set(-5, 3, -5);
            scene.add(redLight);
            
            // è¾…åŠ©å…‰æºï¼ˆç»¿è‰²ï¼‰
            const greenLight = new THREE.PointLight(0x2a5c2a, 0.8, 30);
            greenLight.position.set(5, 2, -5);
            scene.add(greenLight);
            
            // ä½“ç§¯å…‰æ•ˆæœ
            const volumetricLight = new THREE.SpotLight(0xd4af37, 2, 30, Math.PI / 6, 0.5, 1);
            volumetricLight.position.set(0, 15, 0);
            volumetricLight.target.position.set(0, 0, 0);
            scene.add(volumetricLight);
            scene.add(volumetricLight.target);
        }
        
        // åŠ è½½é»˜è®¤çº¹ç†
        async function loadDefaultTextures() {
            const textureLoader = new THREE.TextureLoader();
            photoTextures = [];
            
            // åˆ›å»º6ä¸ªé»˜è®¤çº¹ç†ï¼ˆä½¿ç”¨é¢œè‰²å’Œæ–‡å­—ï¼‰
            for (let i = 0; i < defaultPhotos; i++) {
                // åˆ›å»ºCanvasçº¹ç†
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // å®šä¹‰é¢œè‰²æ–¹æ¡ˆ
                const colors = [
                    { bg: '#2a5c2a', text: '#d4af37' }, // å“‘å…‰ç»¿ + é‡‘å±é‡‘
                    { bg: '#8b0000', text: '#f5f5f5' }, // åœ£è¯çº¢ + ç™½
                    { bg: '#0a3d62', text: '#f5f5f5' }, // æ·±è“ + ç™½
                    { bg: '#4a235a', text: '#f5f5f5' }, // ç´«è‰² + ç™½
                    { bg: '#d4af37', text: '#2a5c2a' }, // é‡‘å±é‡‘ + å“‘å…‰ç»¿
                    { bg: '#b22222', text: '#f5f5f5' }  // åœ£è¯çº¢ + ç™½
                ];
                
                const color = colors[i % colors.length];
                
                // ç»˜åˆ¶èƒŒæ™¯
                ctx.fillStyle = color.bg;
                ctx.fillRect(0, 0, 256, 256);
                
                // ç»˜åˆ¶å›¾æ¡ˆ
                ctx.fillStyle = color.text;
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`ç…§ç‰‡ ${i+1}`, 128, 100);
                
                // ç»˜åˆ¶åœ£è¯å›¾æ ‡
                ctx.font = '60px Arial';
                const icons = ['ğŸ„', 'ğŸ', 'â­', 'ğŸ””', 'ğŸ¦Œ', 'â„ï¸'];
                ctx.fillText(icons[i], 128, 170);
                
                // åˆ›å»ºçº¹ç†
                const texture = new THREE.CanvasTexture(canvas);
                photoTextures.push(texture);
            }
            
            updatePhotoCount();
        }
        
        // åˆ›å»ºåœ£è¯æ ‘
        function createChristmasTree() {
            // æ¸…ç©ºç°æœ‰å…ƒç´ 
            treeElements.forEach(element => scene.remove(element));
            photoElements.forEach(element => scene.remove(element));
            treeElements = [];
            photoElements = [];
            targetPositions = {};
            
            // å®šä¹‰é¢œè‰²
            const matteGreen = new THREE.Color(0x2a5c2a);
            const metallicGold = new THREE.Color(0xd4af37);
            const christmasRed = new THREE.Color(0xb22222);
            
            // åˆ›å»ºåœ£è¯æ ‘åœ†é”¥ä½“ï¼ˆä½œä¸ºå‚è€ƒç»“æ„ï¼‰
            const treeHeight = 10;
            const treeRadius = 3;
            const layers = 8;
            
            // åˆ›å»ºä¸åŒå…ƒç´ 
            let elementIndex = 0;
            
            for (let layer = 0; layer < layers; layer++) {
                const layerHeight = treeHeight * (layer / layers);
                const layerRadius = treeRadius * (1 - layer / layers);
                const elementsInLayer = 10 + layer * 3;
                
                for (let i = 0; i < elementsInLayer; i++) {
                    const angle = (i / elementsInLayer) * Math.PI * 2;
                    const radius = layerRadius * (0.7 + Math.random() * 0.3);
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = layerHeight - 2 + Math.random() * 1.5;
                    
                    // éšæœºé€‰æ‹©å…ƒç´ ç±»å‹
                    const elementType = Math.floor(Math.random() * 4);
                    let element;
                    
                    if (elementType === 0) {
                        // çƒä½“ï¼ˆè£…é¥°çƒï¼‰
                        const geometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.2, 16, 16);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: Math.random() > 0.5 ? metallicGold : christmasRed,
                            roughness: 0.3,
                            metalness: 0.7
                        });
                        element = new THREE.Mesh(geometry, material);
                    } else if (elementType === 1) {
                        // ç«‹æ–¹ä½“ï¼ˆç¤¼ç‰©ç›’ï¼‰
                        const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: Math.random() > 0.5 ? matteGreen : christmasRed,
                            roughness: 0.5,
                            metalness: 0.2
                        });
                        element = new THREE.Mesh(geometry, material);
                    } else if (elementType === 2) {
                        // ç³–æœæ£
                        const geometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: christmasRed,
                            roughness: 0.4,
                            metalness: 0.3
                        });
                        element = new THREE.Mesh(geometry, material);
                        element.rotation.x = Math.PI / 2;
                    } else {
                        // ç…§ç‰‡äº‘ï¼ˆä½¿ç”¨å¹³é¢ï¼‰
                        if (photoTextures.length > 0) {
                            const texture = photoTextures[elementIndex % photoTextures.length];
                            const geometry = new THREE.PlaneGeometry(0.6, 0.6);
                            const material = new THREE.MeshStandardMaterial({ 
                                map: texture,
                                side: THREE.DoubleSide,
                                transparent: true,
                                roughness: 0.7,
                                metalness: 0.1
                            });
                            element = new THREE.Mesh(geometry, material);
                            element.userData.isPhoto = true;
                            element.userData.photoIndex = elementIndex % photoTextures.length;
                            photoElements.push(element);
                            elementIndex++;
                        } else {
                            // å¦‚æœæ²¡æœ‰ç…§ç‰‡çº¹ç†ï¼Œä½¿ç”¨å½©è‰²å¹³é¢
                            const geometry = new THREE.PlaneGeometry(0.6, 0.6);
                            const material = new THREE.MeshStandardMaterial({ 
                                color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                                side: THREE.DoubleSide,
                                roughness: 0.7,
                                metalness: 0.1
                            });
                            element = new THREE.Mesh(geometry, material);
                            element.userData.isPhoto = true;
                            element.userData.photoIndex = -1;
                            photoElements.push(element);
                        }
                    }
                    
                    element.castShadow = true;
                    element.receiveShadow = true;
                    element.position.set(x, y, z);
                    
                    // éšæœºæ—‹è½¬
                    element.rotation.x = Math.random() * Math.PI;
                    element.rotation.y = Math.random() * Math.PI;
                    element.rotation.z = Math.random() * Math.PI;
                    
                    // è®¾ç½®ç›®æ ‡ä½ç½®ï¼ˆåˆå§‹ä¸ºå½“å‰ä½ç½®ï¼‰
                    const targetKey = `element_${treeElements.length}`;
                    targetPositions[targetKey] = {
                        position: new THREE.Vector3(x, y, z),
                        rotation: new THREE.Euler(element.rotation.x, element.rotation.y, element.rotation.z),
                        scale: new THREE.Vector3(1, 1, 1)
                    };
                    
                    element.userData.targetKey = targetKey;
                    element.userData.originalPosition = new THREE.Vector3(x, y, z);
                    
                    scene.add(element);
                    treeElements.push(element);
                }
            }
            
            // æ·»åŠ æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeometry = new THREE.ConeGeometry(0.5, 1, 5);
            const starMaterial = new THREE.MeshStandardMaterial({ 
                color: metallicGold,
                emissive: metallicGold,
                emissiveIntensity: 0.5,
                roughness: 0.2,
                metalness: 0.8
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set(0, treeHeight - 1, 0);
            star.castShadow = true;
            scene.add(star);
            treeElements.push(star);
            
            // æ·»åŠ åœ°é¢
            const groundGeometry = new THREE.CircleGeometry(15, 32);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -3;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            const color = new THREE.Color();
            
            for (let i = 0; i < particleCount; i++) {
                // ä½ç½®
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 30;
                positions[i3 + 1] = (Math.random() - 0.5) * 20;
                positions[i3 + 2] = (Math.random() - 0.5) * 30;
                
                // é¢œè‰²
                const colorValue = Math.random();
                if (colorValue < 0.33) {
                    color.set(0xd4af37); // é‡‘è‰²
                } else if (colorValue < 0.66) {
                    color.set(0x2a5c2a); // å“‘å…‰ç»¿
                } else {
                    color.set(0xb22222); // åœ£è¯çº¢
                }
                
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // å¤§å°
                sizes[i] = Math.random() * 0.5 + 0.1;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // ç²’å­æè´¨
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: createParticleTexture() }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    
                    void main() {
                        vec4 texColor = texture2D(pointTexture, gl_PointCoord);
                        gl_FragColor = vec4(vColor, texColor.a);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        // åˆ›å»ºç²’å­çº¹ç†
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // åˆå§‹åŒ–MediaPipe Hands
        async function initMediaPipe() {
            // å¯åŠ¨æ‘„åƒå¤´
            const video = document.getElementById('webcam');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
                
                // åŠ è½½MediaPipe Hands
                const hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults((results) => {
                    handResults = results;
                    processHandGesture(results);
                });
                
                // å¯åŠ¨æ‘„åƒå¤´å¤„ç†
                const camera = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({image: video});
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                
                updateStatus('closed', 'æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œç­‰å¾…æ‰‹åŠ¿');
                
            } catch (error) {
                console.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                updateStatus('error', 'æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™');
                
                // ä½¿ç”¨æ¨¡æ‹Ÿæ‰‹åŠ¿æ•°æ®ç”¨äºæµ‹è¯•
                simulateHandGestures();
            }
        }
        
        // æ¨¡æ‹Ÿæ‰‹åŠ¿ï¼ˆç”¨äºæµ‹è¯•æˆ–æ‘„åƒå¤´ä¸å¯ç”¨æ—¶ï¼‰
        function simulateHandGestures() {
            let simulatedState = 'closed';
            let rotationX = 0;
            let rotationY = 0;
            
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case '1':
                        simulatedState = 'closed';
                        updateStatus('closed', 'æ¨¡æ‹Ÿæ‰‹åŠ¿ï¼šæ¡æ‹³ï¼ˆåœ£è¯æ ‘åˆæ‹¢æ€ï¼‰');
                        break;
                    case '2':
                        simulatedState = 'open';
                        updateStatus('open', 'æ¨¡æ‹Ÿæ‰‹åŠ¿ï¼šå¼ å¼€æ‰‹æŒï¼ˆåœ£è¯æ ‘æ•£å¼€æ€ï¼‰');
                        break;
                    case '3':
                        if (simulatedState === 'open' && photoElements.length > 0) {
                            simulatedState = 'photo';
                            const randomPhoto = photoElements[Math.floor(Math.random() * photoElements.length)];
                            selectPhoto(randomPhoto);
                            updateStatus('photo', 'æ¨¡æ‹Ÿæ‰‹åŠ¿ï¼šæŠ“å–åŠ¨ä½œï¼ˆç…§ç‰‡æ”¾å¤§æ€ï¼‰');
                        }
                        break;
                    case 'ArrowLeft':
                        rotationY += 0.1;
                        break;
                    case 'ArrowRight':
                        rotationY -= 0.1;
                        break;
                    case 'ArrowUp':
                        rotationX += 0.1;
                        break;
                    case 'ArrowDown':
                        rotationX -= 0.1;
                        break;
                    case 'Escape':
                        if (simulatedState === 'photo') {
                            simulatedState = 'open';
                            exitPhotoMode();
                            updateStatus('open', 'é€€å‡ºç…§ç‰‡æ”¾å¤§æ€');
                        }
                        break;
                }
                
                // æ›´æ–°ç›¸æœºæ—‹è½¬
                if (simulatedState === 'open') {
                    camera.position.x = 15 * Math.sin(rotationY);
                    camera.position.z = 15 * Math.cos(rotationY);
                    camera.position.y = 5 + rotationX * 10;
                    camera.lookAt(0, 0, 0);
                }
                
                // æ›´æ–°çŠ¶æ€
                currentState = simulatedState;
               